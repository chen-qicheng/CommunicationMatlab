function BitData = demodqam16opt1(Conste, Normalized)
% 函数描述：对接收到的星座图进行硬判决，采用自己的优化算法（一）
%
% called by：各种需要进行星座解调硬判决的m文件
% 输入参数：
%   Conste：接收到的星座点（已功率归一化）
%   Normalized: 指定功率是否归一化，字符串形式，
%               只能为Normalized或者NonNormalized，否则报错
% 输出参数
%   BitData：输出的0、1比特信息
%
%               Last Version : 1.0
%               This Version : 2.0
%     This File generated by : 张力
%       This File updated by : 张力
%
% Revision History ：
%     时间            具体工作
%     20150719        v1.0的输入参数只能为标量，该版本可以为向量
%
% Email: larlyii@outlook.com


% 星座映射的规则按照MATLAB默认的Gray映射规则，16个星座点分别如下
% 十进制表示如下
% 0   4   12   8
% 1   5   13   9
% 3   7   15  11
% 2   6   14  10
% 二进制表示如下
% 0000    0100    1100    1000
% 0001    0101    1101    1001
% 0011    0111    1111    1011
% 0010    0110    1110    1010

% 25个区域的序号如下
%   5 | 10 | 15 | 20 | 25
% ----|----|----|----|----
%   4 |  9 | 14 | 19 | 24
% ----|----|----|----|----
%   3 |  8 | 13 | 18 | 23
% ----|----|----|----|----
%   2 |  7 | 12 | 17 | 22
% ----|----|----|----|----
%   1 |  6 | 11 | 16 | 21

temp = (0 : 15)';
BIT = de2bi(temp, 'left-msb')'; % 4行16列，每列代表二进制比特串，16列代表16个星座点
% 按照默认映射顺序进行星座点映射
CONSTE = [-3+3j;-3+1j;-3-3j;-3-1j;-1+3j;-1+1j;-1-3j;-1-1j;...
           3+3j; 3+1j; 3-3j; 3-1j; 1+3j; 1+1j; 1-3j; 1-1j].';
MAP = {BIT, CONSTE};
% 25*2 cell类型，第一列存放25个区域对应的比特，第二列存放25个区域对应的星座点的值
TableEachRegion = cell(25, 2);
for i = 1 : 2
    % 列出每个区域四个角上的星座点和对应的二进制比特串，每个区域的星座点排列顺序如下：
    % 只包含1个星座点的区域：略
    % 包含2个星座点的区域：从下到上
    % 包含4个星座点的区域：左下，左上，右下，右上
    TableEachRegion(:,i) = { ...
    ... % 第1列如下
     MAP{i}(:,2+1); ... % 2
    [MAP{i}(:,2+1); MAP{i}(:,3+1)]; ... % 2,3
    [MAP{i}(:,3+1); MAP{i}(:,1+1)]; ... % 3,1
    [MAP{i}(:,1+1); MAP{i}(:,0+1)];  ... % 1,0
     MAP{i}(:,0+1);  ... % 0
    ... % 第2列如下
    [MAP{i}(:,2+1); MAP{i}(:,6+1)]; ... % 2,6
    [MAP{i}(:,2+1); MAP{i}(:,3+1); MAP{i}(:,6+1); MAP{i}(:,7+1)]; ... % 2,3,6,7
    [MAP{i}(:,3+1); MAP{i}(:,1+1); MAP{i}(:,7+1); MAP{i}(:,5+1)]; ... % 3,1,7,5
    [MAP{i}(:,1+1); MAP{i}(:,0+1); MAP{i}(:,5+1); MAP{i}(:,4+1)]; ... % 1,0,5,4
    [MAP{i}(:,0+1); MAP{i}(:,4+1)]; ... % 0,4
    ... % 第3列如下
    [MAP{i}(:,6+1);MAP{i}(:,14+1)]; ... % 6,14
    [MAP{i}(:,6+1);MAP{i}(:,7+1);MAP{i}(:,14+1);MAP{i}(:,15+1)];...% 6,7,14,15
    [MAP{i}(:,7+1);MAP{i}(:,5+1);MAP{i}(:,15+1);MAP{i}(:,13+1)];...% 7,5,15,13
    [MAP{i}(:,5+1);MAP{i}(:,4+1);MAP{i}(:,13+1);MAP{i}(:,12+1)];...% 5,4,13,12
    [MAP{i}(:,4+1);MAP{i}(:,12+1)]; ... % 4,12
    ... % 第4列如下
    [MAP{i}(:,14+1);MAP{i}(:,10+1)]; ... % 14,10
    [MAP{i}(:,14+1);MAP{i}(:,15+1);MAP{i}(:,10+1);MAP{i}(:,11+1)];...
    %14,15,10,11
    [MAP{i}(:,15+1);MAP{i}(:,13+1);MAP{i}(:,11+1);MAP{i}(:,9+1)];... 
    %15,13,11,9
    [MAP{i}(:,13+1);MAP{i}(:,12+1);MAP{i}(:,9+1); MAP{i}(:,8+1)];... 
    %13,12,9,8
    [MAP{i}(:,12+1);MAP{i}(:,8+1)]; ... % 12,8
    ... % 第5列如下
     MAP{i}(:,10+1); ... % 10
    [MAP{i}(:,10+1); MAP{i}(:,11+1)]; ... % 10,11
    [MAP{i}(:,11+1); MAP{i}(:,9+1)]; ... % 11,9
    [MAP{i}(:,9+1);  MAP{i}(:,8+1)]; ... % 9,8
     MAP{i}(:,8+1); ... % 8
    };
end
BITTABLE = TableEachRegion(:, 1);
CONSTETABLE = TableEachRegion(:, 2);

CntEachRegion = zeros(25, 1, 'double'); % 每个区域星座点的个数
for i = 1 : 25
    CntEachRegion(i) = length(CONSTETABLE{i});
end

if strcmp(Normalized, 'Normalized')
    Conste = Conste * sqrt(10); % 去归一化
elseif strcmp(Normalized, 'NonNormalized')
    % do nothing
else
    error('第二个参数必须为Normalized或者NonNormalized');
end

Conste_I = real(Conste);
Conste_Q = imag(Conste);

% 计算每个星座点所处的区域
RegionIdx_I = zeros(length(Conste), 1, 'double');
RegionIdx_Q = zeros(length(Conste), 1, 'double');
RegionIdx_I(Conste_I <  -3) = 0;
RegionIdx_I(Conste_I >= -3 & Conste_I < -1) = 5;
RegionIdx_I(Conste_I >= -1 & Conste_I <  1) = 10;
RegionIdx_I(Conste_I >=  1 & Conste_I <  3) = 15;
RegionIdx_I(Conste_I >=  3) = 20;
RegionIdx_Q(Conste_Q <  -3) = 1;
RegionIdx_Q(Conste_Q >= -3 & Conste_Q < -1) = 2;
RegionIdx_Q(Conste_Q >= -1 & Conste_Q <  1) = 3;
RegionIdx_Q(Conste_Q >=  1 & Conste_Q <  3) = 4;
RegionIdx_Q(Conste_Q >=  3) = 5;
RegionIdx = RegionIdx_I + RegionIdx_Q;

Idx = cell(25, 1);
MinIdx = cell(25, 1);
BitData = zeros(4, length(Conste), 'double');
for i = 1 : 25
    Idx{i} = find(RegionIdx == i);
    if i == 1 || i == 5 || i == 21 || i == 25
        % 处于4个角上的区域，直接判决为对应的星座点
        BitData(:, Idx{i}) = repmat(BITTABLE{i}(1:4), 1, length(Idx{i}));
    else
        [~, MinIdx{i}] = min(abs(repmat(Conste(Idx{i}),1,CntEachRegion(i)) ...
                               - repmat(CONSTETABLE{i}.', length(Idx{i}), 1)).');
        if i == 7 || i ==  8 || i ==  9 || i == 12 || i == 13 ...
                  || i == 14 || i == 17 || i == 18 || i == 19 
            Idx1 = find(MinIdx{i} == 1);
            Idx2 = find(MinIdx{i} == 2);
            Idx3 = find(MinIdx{i} == 3);
            Idx4 = find(MinIdx{i} == 4);
            BitData(:, Idx{i}(Idx1)) = ...
                               repmat(BITTABLE{i}( 1: 4), 1, length(Idx1));
            BitData(:, Idx{i}(Idx2)) = ...
                               repmat(BITTABLE{i}( 5: 8), 1, length(Idx2));
            BitData(:, Idx{i}(Idx3)) = ...
                               repmat(BITTABLE{i}( 9:12), 1, length(Idx3));
            BitData(:, Idx{i}(Idx4)) = ...
                               repmat(BITTABLE{i}(13:16), 1, length(Idx4));
        else
            Idx1 = find(MinIdx{i} == 1);
            Idx2 = find(MinIdx{i} == 2);
            BitData(:, Idx{i}(Idx1)) = ...
                               repmat(BITTABLE{i}( 1: 4), 1, length(Idx1));
            BitData(:, Idx{i}(Idx2)) = ...
                               repmat(BITTABLE{i}( 5: 8), 1, length(Idx2));
        end
    end
end
BitData = reshape(BitData, [], 1);

